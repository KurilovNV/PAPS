# Лабораторная работа 3

# Диаграмма компонентов
 ![Image alt](https://github.com/KurilovNV/PAPS/blob/LabWork3/Lab%20Work%20№3/doc/Диаграмма%20компонентов.png)

# Модель БД
 ![Image alt](https://github.com/KurilovNV/PAPS/blob/LabWork3/Lab%20Work%20№3/doc/База%20данных.png)

 # Применение основных принципов разработки
 ## DRY.
  Функция CheckAnswer принимает два аргумента: предложенный ответ (proposedAnswer) и правильный ответ (correctAnswer).
  Оба ответа преобразуются в нижний регистр с помощью метода ToLower, чтобы сравнение происходило без учета регистра.
  После этого функция сравнивает оба ответа и возвращает результат сравнения.
  Такая реализация позволяет избежать дублирования кода при сравнении ответов на различные задания, соответствуя принципу DRY.
  ```c#
  class TaskChecker
  {
    public static bool CheckAnswer(string proposedAnswer, string correctAnswer)
    {
        string proposedAnswerLower = proposedAnswer.ToLower();
        string correctAnswerLower = correctAnswer.ToLower();
        return proposedAnswerLower == correctAnswerLower;
     }
  }
  ```

  ## YAGNI.
  Функция SendMessage принимает идентификатор чата пользователя (chatId) и текст сообщения (message).
  Формируется URL для отправки сообщения через API телеграм-бота.
  Создается объект WebClient для выполнения HTTP-запроса к API телеграм-бота.
  Выполняется GET-запрос к API сформированным URL.
  Полученный ответ проверяется на наличие ошибок.
  Это минимальная реализация функции для отправки сообщения, соответствующая принципу YAGNI (You Ain't Gonna Need It).
 ```c#
    public static void SendMessage(long chatId, string message)
    {
        string apiUrl = $"https://api.telegram.org/bot{BotToken}/sendMessage?chat_id={chatId}&text={WebUtility.UrlEncode(message)}";

        using (WebClient client = new WebClient())
        {
            try
            {
                string response = client.DownloadString(apiUrl);
                Console.WriteLine($"Сообщение отправлено пользователю {chatId}: {message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка при отправке сообщения: {ex.Message}");
            }
        }
    }
  ```
    
  ## KISS
  Функция AddNoiseToAudio принимает массив байтов, представляющий аудио файл, и просто выводит сообщение о добавлении шума к аудио файлу. Нет излишней сложности или деталей, это соответствует принципу KISS.
 ```c#
    class AudioProcessor
    {
        public static byte[] AddNoiseToAudio(byte[] audioData)
        {
            Console.WriteLine("Noise added to audio file.");
            Random random = new Random();
            byte[] noise = new byte[audioData.Length];
            random.NextBytes(noise);
            for (int i = 0; i < audioData.Length; i++)
            {
                audioData[i] = (byte)(audioData[i] ^ noise[i]);
            }
            return audioData;
        }
     }
```

  
## SOLID:
Класс UserRepository отвечает за сохранение и загрузку пользователей из базы данных. 
Класс User представляет собой модель пользователя.
Каждый класс отвечает за свою область ответственности, что соответствует принципу единственной обязанности (Single Responsibility Principle) из SOLID.
  ```c#
  class UserRepository
  {
       private string _filePath;
   
       public UserRepository(string filePath)
       {
           _filePath = filePath;
       }
       public void SaveUser(User user)
       {
           List<User> users = LoadUsers();
           users.Add(user);
           SaveUsers(users);
       }
       public List<User> LoadUsers()
       {
           if (!File.Exists(_filePath))
               return new List<User>();
   
           string json = File.ReadAllText(_filePath);
           return JsonConvert.DeserializeObject<List<User>>(json);
       }
   
       private void SaveUsers(List<User> users)
       {
           string json = JsonConvert.SerializeObject(users);
           File.WriteAllText(_filePath, json);
       }
   }
  class User
  {
      public long ChatId { get; set; }
      public string Username { get; set; }
  }
  ```
# Дополнительные принципы разработки

- ## BDUF (Big Design Up Front - «Масштабное проектирование прежде всего»):
Применимость: BDUF может быть полезен в проектах, где требования хорошо определены, технологии стабильны, а бизнес-модель не предполагает значительных изменений. Это позволяет снизить риск и затраты на последующие изменения, а также обеспечить более стройную архитектуру и кодирование. Такой подход может быть предпочтителен при разработке критически важных систем, где стабильность и надежность играют решающую роль.

Отказ: BDUF становится неприменимым в ситуациях с высокой степенью неопределенности, когда требования меняются быстро или когда проект является инновационным. В таких случаях строгий план может ограничить гибкость и способность быстро адаптироваться к изменяющейся среде. Кроме того, BDUF может привести к излишней сложности и избыточности в дизайне, что может замедлить разработку и затруднить поддержку в дальнейшем.

- ## SoC (Separation of Concerns - принцип разделения ответственности):
Применимость: Принцип разделения ответственности особенно полезен в больших и сложных проектах, где код может быть легко масштабирован и поддерживаем. Он помогает улучшить структурированность кода, сделать его более читаемым и легко поддерживаемым. Это особенно важно в средах, где несколько команд работают над одним проектом, так как позволяет им работать над отдельными компонентами параллельно.

Отказ: SoC может быть излишним в небольших проектах или в тех случаях, когда разделение кода на отдельные компоненты приводит к избыточной сложности и увеличивает объем работы. В таких ситуациях применение этого принципа может замедлить разработку и усложнить понимание кода.

- ## MVP (Minimum Viable Product - минимально жизнеспособный продукт):
Применимость: MVP подходит для стартапов и инновационных проектов, где необходимо быстро проверить гипотезы и получить обратную связь от пользователей. Он позволяет минимизировать риски и затраты, начать взаимодействие с рынком и итеративно развивать продукт на основе обратной связи. MVP также полезен в ситуациях, когда у команды ограниченные ресурсы и она должна сфокусироваться на ключевых функциях продукта.

Отказ: MVP не всегда применим в случаях, когда требуется предложить полноценное решение, а не просто его часть. Например, в некоторых отраслях, таких как медицина или авиация, невозможно предложить "минимально жизнеспособный" продукт из-за строгих требований к безопасности и надежности.

- ## PoC (Proof of Concept - доказательство концепции):
Применимость: PoC полезен в ситуациях, когда необходимо оценить техническую реализуемость сложных идей или технологий перед тем, как приступить к полноценной разработке. Он помогает убедить инвесторов, заинтересовать заказчиков и определить возможности технической реализации. PoC также может использоваться для демонстрации концепции перед началом разработки.

Отказ: PoC может быть излишним, если техническая реализация идеи является очевидной или если для проверки гипотезы достаточно небольшого эксперимента или исследования. В таких случаях создание PoC может быть излишним затратным и времязатратным процессом.
